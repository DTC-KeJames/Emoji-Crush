<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Emoji Crush - ÊàëÁöÑËá™Ë£ΩÊ∂àÊ∂àÊ®Ç</title>
    
    <!-- Open Graph Tags -->
    <meta property="og:title" content="Emoji Crush - ÊàëÁöÑËá™Ë£ΩÊ∂àÊ∂àÊ®Ç" />
    <meta property="og:description" content="Âø´‰æÜÁé©ÊàëÁî® AI ÂØ´ÁöÑË∂ÖËàíÂ£ìÊ∂àÊ∂àÊ®ÇÈÅäÊà≤ÔºÅ" />
    <meta property="og:image" content="https://picsum.photos/1200/630" />
    <meta property="og:type" content="website" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for external dependencies -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "framer-motion": "https://esm.sh/framer-motion@10.16.4",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0",
    "uuid": "https://esm.sh/uuid@9.0.1",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
    
    <style>
      body {
        user-select: none;
        -webkit-user-select: none;
        overflow: hidden; /* Prevent pull-to-refresh on mobile */
        touch-action: none;
      }
    </style>
  </head>
  <body class="bg-pink-50 text-slate-800 antialiased">
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, memo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { motion, AnimatePresence } from 'framer-motion';
      import { Clock, Trophy, RotateCcw, RefreshCw } from 'lucide-react';
      import { v4 as uuidv4 } from 'uuid';

      // --- Constants ---
      const BOARD_SIZE = 8;
      const GAME_DURATION = 60; // seconds
      const EMOJIS = ['üçé', 'üçá', 'üçä', 'üçã', 'ü´ê', 'ü••'];
      
      const POINTS_PER_GEM = 10;
      const POINTS_COMBO_BONUS = 50;
      const POINTS_PER_SECOND_LEFT = 5;

      // --- Services ---
      const getRandomEmoji = () => {
        return EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
      };

      const generateBoard = () => {
        const cells = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            let type;
            // Keep generating until no match is formed
            do {
              type = getRandomEmoji();
            } while (
              (col >= 2 && cells[row * BOARD_SIZE + col - 1].type === type && cells[row * BOARD_SIZE + col - 2].type === type) ||
              (row >= 2 && cells[(row - 1) * BOARD_SIZE + col].type === type && cells[(row - 2) * BOARD_SIZE + col].type === type)
            );

            cells.push({
              id: uuidv4(),
              type,
              row,
              col
            });
          }
        }
        return cells;
      };

      const findMatches = (cells) => {
        const matchedIds = new Set();

        const getCell = (r, c) => {
          if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) return null;
          return cells.find(cell => cell.row === r && cell.col === c) || null;
        };

        // Horizontal matches
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE - 2; col++) {
            const c1 = getCell(row, col);
            const c2 = getCell(row, col + 1);
            const c3 = getCell(row, col + 2);

            if (c1 && c2 && c3 && c1.type === c2.type && c2.type === c3.type) {
              matchedIds.add(c1.id);
              matchedIds.add(c2.id);
              matchedIds.add(c3.id);
            }
          }
        }

        // Vertical matches
        for (let col = 0; col < BOARD_SIZE; col++) {
          for (let row = 0; row < BOARD_SIZE - 2; row++) {
            const c1 = getCell(row, col);
            const c2 = getCell(row + 1, col);
            const c3 = getCell(row + 2, col);

            if (c1 && c2 && c3 && c1.type === c2.type && c2.type === c3.type) {
              matchedIds.add(c1.id);
              matchedIds.add(c2.id);
              matchedIds.add(c3.id);
            }
          }
        }

        return Array.from(matchedIds);
      };

      const isAdjacent = (p1, p2) => {
        const dx = Math.abs(p1.col - p2.col);
        const dy = Math.abs(p1.row - p2.row);
        return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
      };

      // --- Components ---

      // 1. Gem Component
      const Gem = memo(({ cell, isSelected, onInteract, widthPercentage }) => {
        return (
          <motion.div
            layout
            layoutId={cell.id}
            initial={{ scale: 0, opacity: 0 }}
            animate={{ 
              scale: isSelected ? 1.15 : 1,
              opacity: 1,
              rotate: isSelected ? [0, -10, 10, 0] : 0,
              zIndex: isSelected ? 10 : 1
            }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ 
              type: "spring", 
              stiffness: 300, 
              damping: 20,
              layout: { duration: 0.2 }
            }}
            onClick={() => onInteract(cell)}
            className={`
              absolute flex items-center justify-center cursor-pointer
              select-none p-1.5
            `}
            style={{
              width: `${widthPercentage}%`,
              height: `${widthPercentage}%`,
              left: `${cell.col * widthPercentage}%`,
              top: `${cell.row * widthPercentage}%`,
            }}
            whileTap={{ scale: 0.8 }}
            whileHover={{ scale: 1.05 }}
          >
            <div className={`
              w-full h-full flex items-center justify-center rounded-2xl
              transition-all duration-200
              ${isSelected 
                ? 'bg-white/60 shadow-lg ring-4 ring-white' 
                : 'hover:bg-white/20'
              }
            `}>
              <span className="text-[clamp(1.5rem,5vw,3rem)] leading-none filter drop-shadow-sm">
                {cell.type}
              </span>
            </div>
          </motion.div>
        );
      });

      // 2. Header Component
      const Header = ({ score, timeLeft, onRestart }) => {
        const isWarning = timeLeft <= 10;

        return (
          <div className="w-full max-w-md px-4 py-4 flex flex-col gap-4">
            <h1 className="text-4xl font-black text-center text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 drop-shadow-sm tracking-tight font-sans">
              Emoji Crush
            </h1>

            <div className="flex justify-between items-center bg-white/60 backdrop-blur-md rounded-2xl p-3 shadow-sm border border-white/50">
              
              {/* Score */}
              <div className="flex items-center gap-2">
                <div className="bg-yellow-100 p-2 rounded-xl text-yellow-600">
                  <Trophy size={20} fill="currentColor" />
                </div>
                <div className="flex flex-col">
                  <span className="text-xs font-bold text-slate-400 uppercase">Score</span>
                  <span className="text-xl font-black text-slate-700 leading-none">{score.toLocaleString()}</span>
                </div>
              </div>

              {/* Timer */}
              <div className={`flex items-center gap-2 transition-colors duration-300 ${isWarning ? 'text-red-500' : 'text-slate-700'}`}>
                <div className={`p-2 rounded-xl ${isWarning ? 'bg-red-100 animate-pulse' : 'bg-blue-100 text-blue-600'}`}>
                  <Clock size={20} />
                </div>
                <div className="flex flex-col">
                   <span className="text-xs font-bold text-slate-400 uppercase">Time</span>
                   <span className="text-xl font-black leading-none">{timeLeft}s</span>
                </div>
              </div>

              {/* Restart Button */}
              <button 
                onClick={onRestart}
                className="p-3 bg-pink-100 text-pink-600 rounded-xl hover:bg-pink-200 active:scale-90 transition-all"
              >
                <RotateCcw size={20} />
              </button>

            </div>
          </div>
        );
      };

      // 3. GameOver Component
      const GameOver = ({ score, onRestart }) => {
        return (
          <div className="absolute inset-0 z-50 flex items-center justify-center p-4 bg-black/20 backdrop-blur-sm">
            <motion.div 
              initial={{ scale: 0.8, opacity: 0, y: 50 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              className="bg-white rounded-3xl p-8 shadow-2xl max-w-sm w-full text-center border-4 border-pink-100"
            >
              <div className="inline-flex items-center justify-center w-20 h-20 bg-yellow-100 text-yellow-500 rounded-full mb-6 shadow-inner">
                <Trophy size={40} fill="currentColor" />
              </div>
              
              <h2 className="text-3xl font-black text-slate-800 mb-2">Time's Up!</h2>
              <p className="text-slate-500 mb-8 font-medium">Amazing job! Here is your final score:</p>
              
              <div className="bg-slate-50 rounded-2xl p-6 mb-8 border border-slate-100">
                <span className="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-br from-pink-500 to-purple-600">
                  {score.toLocaleString()}
                </span>
              </div>

              <button
                onClick={onRestart}
                className="w-full py-4 bg-gradient-to-r from-pink-500 to-purple-500 text-white rounded-xl font-bold text-lg shadow-lg shadow-pink-200 hover:shadow-pink-300 active:scale-95 transition-all flex items-center justify-center gap-2"
              >
                <RefreshCw size={20} />
                Play Again
              </button>
            </motion.div>
          </div>
        );
      };

      // --- Main App Component ---
      const App = () => {
        const GameState = {
          IDLE: 0,
          SWAPPING: 1,
          MATCHING: 2,
          DROPPING: 3,
          GAME_OVER: 4
        };

        const [board, setBoard] = useState([]);
        const [gameState, setGameState] = useState(GameState.IDLE);
        const [selectedCell, setSelectedCell] = useState(null);
        const [score, setScore] = useState(0);
        const [timeLeft, setTimeLeft] = useState(GAME_DURATION);

        // Timer Logic
        useEffect(() => {
          let timer;
          if (gameState !== GameState.GAME_OVER && timeLeft > 0) {
            timer = setInterval(() => {
              setTimeLeft((prev) => {
                if (prev <= 1) {
                  setGameState(GameState.GAME_OVER);
                  return 0;
                }
                return prev - 1;
              });
            }, 1000);
          }
          return () => clearInterval(timer);
        }, [timeLeft, gameState, GameState.GAME_OVER]);

        useEffect(() => {
          startNewGame();
        }, []);

        const startNewGame = () => {
          setBoard(generateBoard());
          setScore(0);
          setTimeLeft(GAME_DURATION);
          setGameState(GameState.IDLE);
          setSelectedCell(null);
        };

        const processBoard = useCallback(async (currentBoard, isUserMove) => {
          const matchedIds = findMatches(currentBoard);

          if (matchedIds.length === 0) {
            setGameState(GameState.IDLE);
            return;
          }

          setGameState(GameState.MATCHING);
          
          if (matchedIds.length > 0) {
              setScore(prev => prev + (matchedIds.length * POINTS_PER_GEM));
          }

          await new Promise(resolve => setTimeout(resolve, 300));

          // Remove matches & Create Grid
          let grid = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
          currentBoard.forEach(c => {
            if (!matchedIds.includes(c.id)) {
              grid[c.row][c.col] = c;
            }
          });

          // Apply Gravity
          for (let col = 0; col < BOARD_SIZE; col++) {
            let emptySlots = 0;
            for (let row = BOARD_SIZE - 1; row >= 0; row--) {
              if (grid[row][col] === null) {
                emptySlots++;
              } else if (emptySlots > 0) {
                const cell = grid[row][col];
                cell.row += emptySlots;
                grid[row][col] = null;
                grid[cell.row][col] = cell;
              }
            }
          }

          // Refill
          const finalCells = [];
          for (let col = 0; col < BOARD_SIZE; col++) {
             let currentRow = BOARD_SIZE - 1;
             const colCells = currentBoard.filter(c => c.col === col && !matchedIds.includes(c.id));
             colCells.sort((a, b) => b.row - a.row);
             
             colCells.forEach((cell, idx) => {
                cell.row = BOARD_SIZE - 1 - idx;
                finalCells.push(cell);
             });

             const numMissing = BOARD_SIZE - colCells.length;
             for (let i = 0; i < numMissing; i++) {
               finalCells.push({
                 id: uuidv4(),
                 type: getRandomEmoji(),
                 col: col,
                 row: (numMissing - 1) - i
               });
             }
          }

          setBoard(finalCells);
          setGameState(GameState.DROPPING);

          await new Promise(resolve => setTimeout(resolve, 500));

          processBoard(finalCells, false);

        }, []);

        const handleCellInteraction = async (clickedCell) => {
          if (gameState !== GameState.IDLE) return;

          if (!selectedCell) {
            setSelectedCell(clickedCell);
            return;
          }

          if (selectedCell.id === clickedCell.id) {
            setSelectedCell(null);
            return;
          }

          if (!isAdjacent(selectedCell, clickedCell)) {
            setSelectedCell(clickedCell);
            return;
          }

          setGameState(GameState.SWAPPING);
          
          const newBoard = board.map(c => {
            if (c.id === selectedCell.id) return { ...c, row: clickedCell.row, col: clickedCell.col };
            if (c.id === clickedCell.id) return { ...c, row: selectedCell.row, col: selectedCell.col };
            return c;
          });

          setBoard(newBoard);
          setSelectedCell(null);

          await new Promise(resolve => setTimeout(resolve, 300));

          const matches = findMatches(newBoard);

          if (matches.length > 0) {
            processBoard(newBoard, true);
          } else {
            const revertedBoard = newBoard.map(c => {
              if (c.id === selectedCell.id) return { ...c, row: selectedCell.row, col: selectedCell.col };
              if (c.id === clickedCell.id) return { ...c, row: clickedCell.row, col: clickedCell.col };
              return c;
            });
            setBoard(revertedBoard);
            setGameState(GameState.IDLE);
          }
        };

        const cellSizePercentage = 100 / BOARD_SIZE;

        return (
          <div className="min-h-screen w-full bg-gradient-to-br from-pink-100 via-purple-100 to-blue-100 flex flex-col items-center justify-center font-sans overflow-hidden relative">
            
            <div className="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none opacity-50">
               <div className="absolute top-10 left-10 text-6xl opacity-20 animate-bounce">üç¨</div>
               <div className="absolute bottom-20 right-20 text-6xl opacity-20 animate-pulse">üç≠</div>
               <div className="absolute top-1/2 left-5 text-4xl opacity-20 rotate-45">üç©</div>
            </div>

            <Header score={score} timeLeft={timeLeft} onRestart={startNewGame} />

            <div className="w-full max-w-md p-4 relative z-10">
              <div 
                className="relative w-full aspect-square bg-white/40 backdrop-blur-xl rounded-3xl shadow-2xl border-4 border-white/50 overflow-hidden"
                style={{ touchAction: 'none' }}
              >
                <AnimatePresence>
                  {board.map((cell) => (
                    <Gem
                      key={cell.id}
                      cell={cell}
                      widthPercentage={cellSizePercentage}
                      isSelected={selectedCell?.id === cell.id}
                      onInteract={handleCellInteraction}
                    />
                  ))}
                </AnimatePresence>
              </div>
            </div>

            <div className="mt-4 text-slate-500 text-sm font-medium text-center px-6">
              <p>Tap two adjacent emojis to swap.</p>
              <p>Match 3 or more to score!</p>
            </div>

            <AnimatePresence>
              {gameState === GameState.GAME_OVER && (
                <GameOver score={score} onRestart={startNewGame} />
              )}
            </AnimatePresence>
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>